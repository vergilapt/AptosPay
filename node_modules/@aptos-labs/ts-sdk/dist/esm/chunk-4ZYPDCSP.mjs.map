{"version":3,"sources":["../../src/transactions/transactionBuilder/signingMessage.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file handles the generation of the signing message.\n * @group Implementation\n * @category Transactions\n */\nimport { sha3_256 as sha3Hash } from \"@noble/hashes/sha3\";\nimport { RAW_TRANSACTION_SALT, RAW_TRANSACTION_WITH_DATA_SALT } from \"../../utils/const\";\nimport { FeePayerRawTransaction, MultiAgentRawTransaction } from \"../instances\";\nimport { AnyRawTransaction, AnyRawTransactionInstance } from \"../types\";\nimport { Serializable } from \"../../bcs\";\n\n/**\n * Derives the appropriate raw transaction type based on the provided transaction details.\n * This function helps in identifying whether the transaction is a FeePayerRawTransaction,\n * MultiAgentRawTransaction, or a standard RawTransaction.\n *\n * @param transaction - An object representing an Aptos transaction, which may include:\n *   - feePayerAddress - The address of the fee payer (optional).\n *   - secondarySignerAddresses - An array of secondary signer addresses (optional).\n *   - rawTransaction - The raw transaction data.\n *\n * @returns FeePayerRawTransaction | MultiAgentRawTransaction | RawTransaction\n * @group Implementation\n * @category Transactions\n */\nexport function deriveTransactionType(transaction: AnyRawTransaction): AnyRawTransactionInstance {\n  if (transaction.feePayerAddress) {\n    return new FeePayerRawTransaction(\n      transaction.rawTransaction,\n      transaction.secondarySignerAddresses ?? [],\n      transaction.feePayerAddress,\n    );\n  }\n  if (transaction.secondarySignerAddresses) {\n    return new MultiAgentRawTransaction(transaction.rawTransaction, transaction.secondarySignerAddresses);\n  }\n\n  return transaction.rawTransaction;\n}\n\n/**\n * Generates the 'signing message' form of a message to be signed.\n * This function combines a domain separator with the byte representation of the message to create a signing message.\n *\n * @param bytes - The byte representation of the message to be signed and sent to the chain.\n * @param domainSeparator - A domain separator that starts with 'APTOS::'.\n *\n * @returns The Uint8Array of the signing message.\n * @group Implementation\n * @category Transactions\n */\nexport function generateSigningMessage(bytes: Uint8Array, domainSeparator: string): Uint8Array {\n  const hash = sha3Hash.create();\n\n  if (!domainSeparator.startsWith(\"APTOS::\")) {\n    throw new Error(`Domain separator needs to start with 'APTOS::'.  Provided - ${domainSeparator}`);\n  }\n\n  hash.update(domainSeparator);\n\n  const prefix = hash.digest();\n\n  const body = bytes;\n\n  const mergedArray = new Uint8Array(prefix.length + body.length);\n  mergedArray.set(prefix);\n  mergedArray.set(body, prefix.length);\n\n  return mergedArray;\n}\n\n/**\n * @deprecated\n * Use CryptoHashable instead by having your class implement it and call hash() to get the signing message.\n *\n * Generates the 'signing message' form of a serializable value by serializing it and using the constructor name as the domain\n * separator.\n *\n * @param serializable - An object that has a BCS serialized form.\n *\n * @returns The Uint8Array of the signing message.\n * @group Implementation\n * @category Transactions\n */\nexport function generateSigningMessageForSerializable(serializable: Serializable): Uint8Array {\n  return generateSigningMessage(serializable.bcsToBytes(), `APTOS::${serializable.constructor.name}`);\n}\n\n/**\n * Generates the 'signing message' form of a transaction by deriving the type of transaction and applying the appropriate domain\n * separator based on the presence of a fee payer or secondary signers.\n *\n * @param transaction - A transaction that is to be signed, which can include a fee payer address or secondary signer addresses.\n *\n * @returns The Uint8Array of the signing message.\n * @group Implementation\n * @category Transactions\n */\nexport function generateSigningMessageForTransaction(transaction: AnyRawTransaction): Uint8Array {\n  const rawTxn = deriveTransactionType(transaction);\n  if (transaction.feePayerAddress) {\n    return generateSigningMessage(rawTxn.bcsToBytes(), RAW_TRANSACTION_WITH_DATA_SALT);\n  }\n  if (transaction.secondarySignerAddresses) {\n    return generateSigningMessage(rawTxn.bcsToBytes(), RAW_TRANSACTION_WITH_DATA_SALT);\n  }\n  return generateSigningMessage(rawTxn.bcsToBytes(), RAW_TRANSACTION_SALT);\n}\n"],"mappings":"gGAQA,OAAS,YAAYA,MAAgB,qBAoB9B,SAASC,EAAsBC,EAA2D,CAC/F,OAAIA,EAAY,gBACP,IAAIC,EACTD,EAAY,eACZA,EAAY,0BAA4B,CAAC,EACzCA,EAAY,eACd,EAEEA,EAAY,yBACP,IAAIE,EAAyBF,EAAY,eAAgBA,EAAY,wBAAwB,EAG/FA,EAAY,cACrB,CAaO,SAASG,EAAuBC,EAAmBC,EAAqC,CAC7F,IAAMC,EAAOC,EAAS,OAAO,EAE7B,GAAI,CAACF,EAAgB,WAAW,SAAS,EACvC,MAAM,IAAI,MAAM,+DAA+DA,CAAe,EAAE,EAGlGC,EAAK,OAAOD,CAAe,EAE3B,IAAMG,EAASF,EAAK,OAAO,EAErBG,EAAOL,EAEPM,EAAc,IAAI,WAAWF,EAAO,OAASC,EAAK,MAAM,EAC9D,OAAAC,EAAY,IAAIF,CAAM,EACtBE,EAAY,IAAID,EAAMD,EAAO,MAAM,EAE5BE,CACT,CAeO,SAASC,EAAsCC,EAAwC,CAC5F,OAAOT,EAAuBS,EAAa,WAAW,EAAG,UAAUA,EAAa,YAAY,IAAI,EAAE,CACpG,CAYO,SAASC,EAAqCb,EAA4C,CAC/F,IAAMc,EAASf,EAAsBC,CAAW,EAChD,OAAIA,EAAY,gBACPG,EAAuBW,EAAO,WAAW,EAAGC,CAA8B,EAE/Ef,EAAY,yBACPG,EAAuBW,EAAO,WAAW,EAAGC,CAA8B,EAE5EZ,EAAuBW,EAAO,WAAW,EAAGE,CAAoB,CACzE","names":["sha3Hash","deriveTransactionType","transaction","FeePayerRawTransaction","MultiAgentRawTransaction","generateSigningMessage","bytes","domainSeparator","hash","sha3Hash","prefix","body","mergedArray","generateSigningMessageForSerializable","serializable","generateSigningMessageForTransaction","rawTxn","RAW_TRANSACTION_WITH_DATA_SALT","RAW_TRANSACTION_SALT"]}