import { a as AccountPublicKey, A as AuthenticationKey, P as PublicKey } from '../../publicKey-BMtGNNLg.mjs';
import { Deserializer } from '../../bcs/deserializer.mjs';
import { Serializer } from '../../bcs/serializer.mjs';
import { HexInput } from '../../types/types.mjs';
import { AccountAddress, AccountAddressInput } from '../accountAddress.mjs';
import { KeylessPublicKey, KeylessSignature } from './keyless.mjs';
import '../hex.mjs';
import '../common.mjs';
import './signature.mjs';
import '../../types/indexer.mjs';
import '../../types/generated/operations.mjs';
import '../../types/generated/types.mjs';
import '../../utils/apiEndpoints.mjs';
import '../../transactions/instances/transactionArgument.mjs';
import './ephemeral.mjs';
import './proof.mjs';
import '../../types/keyless.mjs';
import '../../api/aptosConfig.mjs';
import '../../utils/const.mjs';

/**
 * Represents the FederatedKeylessPublicKey public key
 *
 * These keys use an on-chain address as a source of truth for the JWK used to verify signatures.
 *
 * FederatedKeylessPublicKey authentication key is represented in the SDK as `AnyPublicKey`.
 * @group Implementation
 * @category Serialization
 */
declare class FederatedKeylessPublicKey extends AccountPublicKey {
    /**
     * The address that contains the JWK set to be used for verification.
     * @group Implementation
     * @category Serialization
     */
    readonly jwkAddress: AccountAddress;
    /**
     * The inner public key which contains the standard Keyless public key.
     * @group Implementation
     * @category Serialization
     */
    readonly keylessPublicKey: KeylessPublicKey;
    constructor(jwkAddress: AccountAddressInput, keylessPublicKey: KeylessPublicKey);
    /**
     * Get the authentication key for the federated keyless public key
     *
     * @returns AuthenticationKey
     * @group Implementation
     * @category Serialization
     */
    authKey(): AuthenticationKey;
    /**
     * Verifies a signed data with a public key
     *
     * @param args.message message
     * @param args.signature The signature
     * @returns true if the signature is valid
     * @group Implementation
     * @category Serialization
     */
    verifySignature(args: {
        message: HexInput;
        signature: KeylessSignature;
    }): boolean;
    serialize(serializer: Serializer): void;
    static deserialize(deserializer: Deserializer): FederatedKeylessPublicKey;
    static isPublicKey(publicKey: PublicKey): publicKey is FederatedKeylessPublicKey;
    /**
     * Creates a FederatedKeylessPublicKey from the JWT components plus pepper
     *
     * @param args.iss the iss of the identity
     * @param args.uidKey the key to use to get the uidVal in the JWT token
     * @param args.uidVal the value of the uidKey in the JWT token
     * @param args.aud the client ID of the application
     * @param args.pepper The pepper used to maintain privacy of the account
     * @returns FederatedKeylessPublicKey
     * @group Implementation
     * @category Serialization
     */
    static create(args: {
        iss: string;
        uidKey: string;
        uidVal: string;
        aud: string;
        pepper: HexInput;
        jwkAddress: AccountAddressInput;
    }): FederatedKeylessPublicKey;
    static fromJwtAndPepper(args: {
        jwt: string;
        pepper: HexInput;
        jwkAddress: AccountAddressInput;
        uidKey?: string;
    }): FederatedKeylessPublicKey;
    static isInstance(publicKey: PublicKey): boolean;
}

export { FederatedKeylessPublicKey };
