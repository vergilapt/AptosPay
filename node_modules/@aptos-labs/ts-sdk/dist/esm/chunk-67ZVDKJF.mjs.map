{"version":3,"sources":["../../src/api/transaction.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AptosConfig } from \"./aptosConfig\";\nimport {\n  getGasPriceEstimation,\n  getTransactionByHash,\n  getTransactionByVersion,\n  getTransactions,\n  isTransactionPending,\n  waitForTransaction,\n} from \"../internal/transaction\";\nimport {\n  AnyNumber,\n  CommittedTransactionResponse,\n  GasEstimation,\n  HexInput,\n  PaginationArgs,\n  PendingTransactionResponse,\n  TransactionResponse,\n  WaitForTransactionOptions,\n} from \"../types\";\nimport {\n  FeePayerOrFeePayerAuthenticatorOrNeither,\n  getSigningMessage,\n  publicPackageTransaction,\n  rotateAuthKey,\n  signAndSubmitAsFeePayer,\n  signAndSubmitTransaction,\n  signAsFeePayer,\n  signTransaction,\n} from \"../internal/transactionSubmission\";\nimport {\n  AccountAuthenticator,\n  AnyRawTransaction,\n  InputGenerateTransactionOptions,\n  InputGenerateTransactionPayloadData,\n} from \"../transactions\";\nimport { AccountAddressInput, PrivateKeyInput } from \"../core\";\nimport { Account } from \"../account\";\nimport { Build } from \"./transactionSubmission/build\";\nimport { Simulate } from \"./transactionSubmission/simulate\";\nimport { Submit } from \"./transactionSubmission/submit\";\nimport { TransactionManagement } from \"./transactionSubmission/management\";\nimport { SimpleTransaction } from \"../transactions/instances/simpleTransaction\";\n\n/**\n * Represents a transaction in the Aptos blockchain,\n * providing methods to build, simulate, submit, and manage transactions.\n * This class encapsulates functionalities for querying transaction details,\n * estimating gas prices, signing transactions, and handling transaction states.\n *\n * This class is used as part of the Aptos object, so should be called like so:\n * @example\n * ```typescript\n * import { Account, Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n *\n * const APTOS_COIN = \"0x1::aptos_coin::AptosCoin\";\n * const COIN_STORE = `0x1::coin::CoinStore<${APTOS_COIN}>`;\n * const ALICE_INITIAL_BALANCE = 100_000_000;\n * const TRANSFER_AMOUNT = 100;\n *\n * async function example() {\n *   console.log(\n *     \"This example will create two accounts (Alice and Bob), fund them, and transfer between them.\",\n *   );\n *\n *   // Set up the client\n *   const config = new AptosConfig({ network: Network.DEVNET });\n *   const aptos = new Aptos(config);\n *\n *   // Generate two account credentials\n *   // Each account has a private key, a public key, and an address\n *   const alice = Account.generate();\n *   const bob = Account.generate();\n *\n *   console.log(\"=== Addresses ===\\n\");\n *   console.log(`Alice's address is: ${alice.accountAddress}`);\n *   console.log(`Bob's address is: ${bob.accountAddress}`);\n *\n *   // Fund the accounts using a faucet\n *   console.log(\"\\n=== Funding accounts ===\\n\");\n *\n *   await aptos.fundAccount({\n *     accountAddress: alice.accountAddress,\n *     amount: ALICE_INITIAL_BALANCE,\n *   });\n *\n *   // Send a transaction from Alice's account to Bob's account\n *   const txn = await aptos.transaction.build.simple({\n *     sender: alice.accountAddress,\n *     data: {\n *       // All transactions on Aptos are implemented via smart contracts.\n *       function: \"0x1::aptos_account::transfer\",\n *       functionArguments: [bob.accountAddress, 100],\n *     },\n *   });\n *\n *   console.log(\"\\n=== Transfer transaction ===\\n\");\n *   // Both signs and submits\n *   const committedTxn = await aptos.signAndSubmitTransaction({\n *     signer: alice,\n *     transaction: txn,\n *  });\n *   // Waits for Aptos to verify and execute the transaction\n *   const executedTransaction = await aptos.waitForTransaction({\n *     transactionHash: committedTxn.hash,\n *   });\n *   console.log(\"Transaction hash:\", executedTransaction.hash);\n *\n *  console.log(\"\\n=== Balances after transfer ===\\n\");\n *  const newAliceAccountBalance = await aptos.getAccountResource({\n *    accountAddress: alice.accountAddress,\n *    resourceType: COIN_STORE,\n *  });\n *  const newAliceBalance = Number(newAliceAccountBalance.coin.value);\n *  console.log(`Alice's balance is: ${newAliceBalance}`);\n *\n *  const newBobAccountBalance = await aptos.getAccountResource({\n *    accountAddress: bob.accountAddress,\n *    resourceType: COIN_STORE,\n *  });\n *  const newBobBalance = Number(newBobAccountBalance.coin.value);\n *  console.log(`Bob's balance is: ${newBobBalance}`);\n * }\n *\n * example();\n * ```\n * @group Transaction\n */\nexport class Transaction {\n  readonly config: AptosConfig;\n\n  readonly build: Build;\n\n  readonly simulate: Simulate;\n\n  readonly submit: Submit;\n\n  readonly batch: TransactionManagement;\n\n  /**\n   * Creates an instance of the Aptos client with the specified configuration.\n   * This allows you to interact with the Aptos blockchain using the provided settings.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   * @param config.network - The network to connect to (e.g., Testnet, Mainnet).\n   * @param config.nodeUrl - The URL of the Aptos node to connect to.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a new Aptos client instance\n   *     const config = new AptosConfig({ network: Network.TESTNET }); // Specify the network\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client created successfully:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  constructor(config: AptosConfig) {\n    this.config = config;\n    this.build = new Build(this.config);\n    this.simulate = new Simulate(this.config);\n    this.submit = new Submit(this.config);\n    this.batch = new TransactionManagement(this.config);\n  }\n\n  /**\n   * Queries on-chain transactions, excluding pending transactions.\n   * Use this function to retrieve historical transactions from the blockchain.\n   *\n   * @param args Optional parameters for pagination.\n   * @param args.options Optional pagination options.\n   * @param args.options.offset The number of the transaction to start with.\n   * @param args.options.limit The number of results to return.\n   *\n   * @returns An array of on-chain transactions.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetch transactions with pagination\n   *   const transactions = await aptos.getTransactions({\n   *     options: {\n   *       offset: 0, // Start from the first transaction\n   *       limit: 10, // Limit to 10 results\n   *     },\n   *   });\n   *\n   *   console.log(transactions);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  async getTransactions(args?: { options?: PaginationArgs }): Promise<TransactionResponse[]> {\n    return getTransactions({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries on-chain transaction by version. This function will not return pending transactions.\n   *\n   * @param args - The arguments for querying the transaction.\n   * @param args.ledgerVersion - Transaction version is an unsigned 64-bit number.\n   * @returns On-chain transaction. Only on-chain transactions have versions, so this\n   * function cannot be used to query pending transactions.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching a transaction by its version\n   *   const transaction = await aptos.getTransactionByVersion({ ledgerVersion: 1 }); // replace 1 with a real version\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  async getTransactionByVersion(args: { ledgerVersion: AnyNumber }): Promise<TransactionResponse> {\n    return getTransactionByVersion({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries on-chain transactions by their transaction hash, returning both pending and committed transactions.\n   *\n   * @param args - The arguments for querying the transaction.\n   * @param args.transactionHash - The transaction hash should be a hex-encoded bytes string with a 0x prefix.\n   * @returns The transaction from the mempool (pending) or the on-chain (committed) transaction.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetch a transaction by its hash\n   *   const transaction = await aptos.getTransactionByHash({ transactionHash: \"0x123\" }); // replace with a real transaction hash\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  async getTransactionByHash(args: { transactionHash: HexInput }): Promise<TransactionResponse> {\n    return getTransactionByHash({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Defines if the specified transaction is currently in a pending state.\n   * This function helps you determine the status of a transaction using its hash.\n   *\n   * @param args - The arguments for the function.\n   * @param args.transactionHash - A hash of the transaction in hexadecimal format.\n   * @returns `true` if the transaction is in a pending state and `false` otherwise.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Check if the transaction is pending using its hash\n   *   const isPendingTransaction = await aptos.isPendingTransaction({ transactionHash: \"0x123\" }); // replace with a real transaction hash\n   *   console.log(\"Is the transaction pending?\", isPendingTransaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  async isPendingTransaction(args: { transactionHash: HexInput }): Promise<boolean> {\n    return isTransactionPending({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Waits for a transaction to move past the pending state and provides the transaction response.\n   * There are 4 cases.\n   * 1. Transaction is successfully processed and committed to the chain.\n   *    - The function will resolve with the transaction response from the API.\n   * 2. Transaction is rejected for some reason, and is therefore not committed to the blockchain.\n   *    - The function will throw an AptosApiError with an HTTP status code indicating some problem with the request.\n   * 3. Transaction is committed but execution failed, meaning no changes were\n   *    written to the blockchain state.\n   *    - If `checkSuccess` is true, the function will throw a FailedTransactionError\n   *      If `checkSuccess` is false, the function will resolve with the transaction response where the `success` field is false.\n   * 4. Transaction does not move past the pending state within `args.options.timeoutSecs` seconds.\n   *    - The function will throw a WaitForTransactionError\n   *\n   * @param args.transactionHash - The hash of a transaction previously submitted to the blockchain.\n   * @param args.options - Optional parameters for waiting behavior.\n   * @param args.options.timeoutSecs - Timeout in seconds. Defaults to 20 seconds.\n   * @param args.options.checkSuccess - A boolean which controls whether the function will error if the transaction failed.\n   * Defaults to true.\n   * @returns The transaction on-chain response.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Wait for a transaction to complete using its hash\n   *   const transactionHash = \"0x123\"; // replace with a real transaction hash\n   *   const transactionResponse = await aptos.waitForTransaction({\n   *     transactionHash,\n   *     options: {\n   *       timeoutSecs: 30, // specify your own timeout if needed\n   *       checkSuccess: true,\n   *     },\n   *   });\n   *\n   *   console.log(transactionResponse);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  async waitForTransaction(args: {\n    transactionHash: HexInput;\n    options?: WaitForTransactionOptions;\n  }): Promise<CommittedTransactionResponse> {\n    return waitForTransaction({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Estimates the gas unit price required to process a transaction on the Aptos blockchain in a timely manner.\n   * This helps users to understand the cost associated with their transactions.\n   * {@link https://api.mainnet.aptoslabs.com/v1/spec#/operations/estimate_gas_price}\n   *\n   * @returns An object containing the estimated gas price.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET }); // Specify your network\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Getting the gas price estimation\n   *   const gasPriceEstimation = await aptos.getGasPriceEstimation();\n   *\n   *   console.log(\"Estimated Gas Price:\", gasPriceEstimation);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  async getGasPriceEstimation(): Promise<GasEstimation> {\n    return getGasPriceEstimation({\n      aptosConfig: this.config,\n    });\n  }\n\n  /**\n   * Returns a signing message for a transaction, allowing a user to sign it using their preferred method before submission to the network.\n   *\n   * @param args - The arguments for obtaining the signing message.\n   * @param args.transaction - A raw transaction for signing elsewhere.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *     const transaction = await aptos.transaction.build.simple({\n   *         sender: \"0x1\", // replace with a real sender address\n   *         data: {\n   *             function: \"0x1::aptos_account::transfer\",\n   *             functionArguments: [\"0x2\", 100], // replace with a real destination address\n   *         },\n   *     });\n   *\n   *     const message = await aptos.getSigningMessage({ transaction });\n   *     console.log(message);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  // eslint-disable-next-line class-methods-use-this\n  getSigningMessage(args: { transaction: AnyRawTransaction }): Uint8Array {\n    return getSigningMessage(args);\n  }\n\n  /**\n   * Generates a transaction to publish a Move package to the blockchain.\n   * This function helps you create a transaction that can be simulated or submitted to the chain for publishing a package.\n   *\n   * To get the `metadataBytes` and `byteCode`, can compile using Aptos CLI with command\n   * `aptos move compile --save-metadata ...`,\n   *\n   * {@link https://aptos.dev/tutorials/your-first-dapp/#step-4-publish-a-move-module}\n   *\n   * @param args The arguments for publishing the package.\n   * @param args.account The publisher account.\n   * @param args.metadataBytes The package metadata bytes.\n   * @param args.moduleBytecode An array of the bytecode of each module in the package in compiler output order.\n   * @param args.options Optional settings for generating the transaction.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Replace with a real account address\n   *   const account = \"0x1\";\n   *   const metadataBytes = \"0x...\"; // replace with real metadata bytes\n   *   const byteCode = \"0x...\"; // replace with real module bytecode\n   *\n   *   const transaction = await aptos.publishPackageTransaction({\n   *     account,\n   *     metadataBytes,\n   *     moduleBytecode: [byteCode],\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  async publishPackageTransaction(args: {\n    account: AccountAddressInput;\n    metadataBytes: HexInput;\n    moduleBytecode: Array<HexInput>;\n    options?: InputGenerateTransactionOptions;\n  }): Promise<SimpleTransaction> {\n    return publicPackageTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Rotate an account's authentication key. After rotation, only the new private key can be used to sign transactions for the account.\n   * Note: Only legacy Ed25519 scheme is supported for now.\n   * More info: {@link https://aptos.dev/guides/account-management/key-rotation/}\n   *\n   * @param args The arguments for rotating the auth key.\n   * @param args.fromAccount The account to rotate the auth key for.\n   * @param args.toNewPrivateKey The new private key to rotate to.\n   *\n   * @returns PendingTransactionResponse\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network, Account, PrivateKey } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Rotate the authentication key for an account\n   *   const response = await aptos.rotateAuthKey({\n   *     // replace with a real account\n   *     fromAccount: Account.generate(),\n   *     // replace with a real private key\n   *     toNewPrivateKey: new PrivateKey(\"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\"),\n   *   });\n   *\n   *   console.log(response);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  async rotateAuthKey(args: { fromAccount: Account; toNewPrivateKey: PrivateKeyInput }): Promise<TransactionResponse> {\n    return rotateAuthKey({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Sign a transaction that can later be submitted to the chain.\n   * This function is essential for ensuring the authenticity of the transaction by using the provided account's signing capabilities.\n   *\n   * @param args - The arguments for signing the transaction.\n   * @param args.signer - The account that will sign the transaction.\n   * @param args.transaction - A raw transaction to sign.\n   *\n   * @returns AccountAuthenticator - The authenticator for the signed transaction.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   const sender = Account.generate(); // Generate a new account for signing\n   *   const transaction = await aptos.transaction.build.simple({\n   *     sender: sender.accountAddress,\n   *     data: {\n   *       function: \"0x1::aptos_account::transfer\",\n   *       functionArguments: [ \"0x1\", 100 ], // replace with a real account address and amount\n   *     },\n   *   });\n   *\n   *   const signedTransaction = await aptos.transaction.sign({\n   *     signer: sender,\n   *     transaction,\n   *   }); // Sign the transaction\n   *\n   *   console.log(\"Signed Transaction:\", signedTransaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  // eslint-disable-next-line class-methods-use-this\n  sign(args: { signer: Account; transaction: AnyRawTransaction }): AccountAuthenticator {\n    return signTransaction({\n      ...args,\n    });\n  }\n\n  /**\n   * Sign a transaction as a fee payer that can later be submitted to the chain.\n   * This function ensures that the transaction is marked with the fee payer's address, allowing it to be processed correctly.\n   *\n   * @param args - The arguments for signing the transaction.\n   * @param args.signer - The fee payer signer account.\n   * @param args.transaction - A raw transaction to sign on. This transaction must include a `feePayerAddress` property.\n   *\n   * @returns AccountAuthenticator - The authenticator for the signed transaction.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   const sender = Account.generate(); // Generate a new account for the fee payer\n   *   const transaction = await aptos.transaction.build.simple({\n   *     // All transactions on Aptos are implemented via smart contracts.\n   *     function: \"0x1::aptos_account::transfer\",\n   *     functionArguments: [sender.accountAddress, 100],\n   *     feePayerAddress: sender.accountAddress, // Set the fee payer address\n   *   });\n   *\n   *   const signedTransaction = await aptos.transaction.signAsFeePayer({\n   *     signer: sender,\n   *     transaction,\n   *   });\n   *\n   *   console.log(\"Signed transaction as fee payer:\", signedTransaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  // eslint-disable-next-line class-methods-use-this\n  signAsFeePayer(args: { signer: Account; transaction: AnyRawTransaction }): AccountAuthenticator {\n    return signAsFeePayer({\n      ...args,\n    });\n  }\n\n  // TRANSACTION SUBMISSION //\n\n  /**\n   * @deprecated Prefer to use `aptos.transaction.batch.forSingleAccount()`\n   *\n   * Batch transactions for a single account by submitting multiple transaction payloads.\n   * This function is useful for efficiently processing and submitting transactions that do not depend on each other, such as\n   * batch funding or batch token minting.\n   *\n   * @param args - The arguments for batching transactions.\n   * @param args.sender - The sender account to sign and submit the transactions.\n   * @param args.data - An array of transaction payloads to be processed.\n   * @param args.options - Optional. Transaction generation configurations (excluding accountSequenceNumber).\n   *\n   * @throws Error if any worker failure occurs during submission.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network, Account } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   * const sender = Account.generate(); // Generate a new account for sending transactions\n   *\n   * async function runExample() {\n   *   const transactions = [\n   *     { }, // Build your first transaction payload\n   *     { }, // Build your second transaction payload\n   *   ];\n   *\n   *   // Batch transactions for the single account\n   *   await aptos.batchTransactionsForSingleAccount({\n   *     sender,\n   *     data: transactions,\n   *   });\n   *\n   *   console.log(\"Batch transactions submitted successfully.\");\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  async batchTransactionsForSingleAccount(args: {\n    sender: Account;\n    data: InputGenerateTransactionPayloadData[];\n    options?: Omit<InputGenerateTransactionOptions, \"accountSequenceNumber\">;\n  }): Promise<void> {\n    try {\n      const { sender, data, options } = args;\n      this.batch.forSingleAccount({ sender, data, options });\n    } catch (error: any) {\n      throw new Error(`failed to submit transactions with error: ${error}`);\n    }\n  }\n\n  /**\n   * Sign and submit a single signer transaction to the blockchain.\n   * This function allows you to execute a transaction after signing it with the specified account.\n   *\n   * @param args The arguments for signing and submitting the transaction.\n   * @param args.signer The signer account to sign the transaction.\n   * @param args.transaction An instance of a RawTransaction, plus optional secondary/fee payer addresses.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   const sender = Account.generate(); // Generate a new account for sending the transaction\n   *   const transaction = await aptos.transaction.build.simple({\n   *     sender: sender.accountAddress,\n   *     data: {\n   *       function: \"0x1::aptos_account::transfer\",\n   *       functionArguments: [ \"0x1\", 100 ], // replace with a real account address\n   *     },\n   *   });\n   *\n   *   // Sign and submit the transaction\n   *   const pendingTransaction = await aptos.signAndSubmitTransaction({\n   *     signer: sender,\n   *     transaction,\n   *   });\n   *\n   *   console.log(pendingTransaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @return PendingTransactionResponse\n   * @group Transaction\n   */\n  async signAndSubmitTransaction(\n    args: FeePayerOrFeePayerAuthenticatorOrNeither & {\n      signer: Account;\n      transaction: AnyRawTransaction;\n    },\n  ): Promise<PendingTransactionResponse> {\n    return signAndSubmitTransaction({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Sign and submit a single signer transaction as the fee payer to chain given an authenticator by the sender of the transaction.\n   *\n   * @param args.feePayer The fee payer account to sign the transaction\n   * @param args.senderAuthenticator The AccountAuthenticator signed by the sender of the transaction\n   * @param args.transaction An instance of a RawTransaction, plus optional secondary/fee payer addresses\n   *\n   * @example\n   * const transaction = await aptos.transaction.build.simple({sender: alice.accountAddress, feePayer: true ...})\n   * const senderAuthenticator = alice.signTransactionWithAuthenticator(transaction)\n   * const pendingTransaction = await aptos.signAndSubmitAsFeePayer({\n   *  senderAuthenticator,\n   *  feePayer: bob,\n   *  transaction,\n   * })\n   *\n   * @return PendingTransactionResponse\n   * @group Transaction\n   */\n  async signAndSubmitAsFeePayer(args: {\n    feePayer: Account;\n    senderAuthenticator: AccountAuthenticator;\n    transaction: AnyRawTransaction;\n  }): Promise<PendingTransactionResponse> {\n    return signAndSubmitAsFeePayer({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n}\n"],"mappings":"yTAkIO,IAAMA,EAAN,KAAkB,CAkCvB,YAAYC,EAAqB,CAC/B,KAAK,OAASA,EACd,KAAK,MAAQ,IAAIC,EAAM,KAAK,MAAM,EAClC,KAAK,SAAW,IAAIC,EAAS,KAAK,MAAM,EACxC,KAAK,OAAS,IAAIC,EAAO,KAAK,MAAM,EACpC,KAAK,MAAQ,IAAIC,EAAsB,KAAK,MAAM,CACpD,CAmCA,MAAM,gBAAgBC,EAAqE,CACzF,OAAOC,EAAgB,CACrB,YAAa,KAAK,OAClB,GAAGD,CACL,CAAC,CACH,CA0BA,MAAM,wBAAwBA,EAAkE,CAC9F,OAAOE,EAAwB,CAC7B,YAAa,KAAK,OAClB,GAAGF,CACL,CAAC,CACH,CA0BA,MAAM,qBAAqBA,EAAmE,CAC5F,OAAOG,EAAqB,CAC1B,YAAa,KAAK,OAClB,GAAGH,CACL,CAAC,CACH,CA0BA,MAAM,qBAAqBA,EAAuD,CAChF,OAAOI,EAAqB,CAC1B,YAAa,KAAK,OAClB,GAAGJ,CACL,CAAC,CACH,CA+CA,MAAM,mBAAmBA,EAGiB,CACxC,OAAOK,EAAmB,CACxB,YAAa,KAAK,OAClB,GAAGL,CACL,CAAC,CACH,CA0BA,MAAM,uBAAgD,CACpD,OAAOM,EAAsB,CAC3B,YAAa,KAAK,MACpB,CAAC,CACH,CAgCA,kBAAkBN,EAAsD,CACtE,OAAOO,EAAkBP,CAAI,CAC/B,CA4CA,MAAM,0BAA0BA,EAKD,CAC7B,OAAOQ,EAAyB,CAAE,YAAa,KAAK,OAAQ,GAAGR,CAAK,CAAC,CACvE,CAmCA,MAAM,cAAcA,EAAgG,CAClH,OAAOS,EAAc,CAAE,YAAa,KAAK,OAAQ,GAAGT,CAAK,CAAC,CAC5D,CAyCA,KAAKA,EAAiF,CACpF,OAAOU,EAAgB,CACrB,GAAGV,CACL,CAAC,CACH,CAwCA,eAAeA,EAAiF,CAC9F,OAAOW,EAAe,CACpB,GAAGX,CACL,CAAC,CACH,CA4CA,MAAM,kCAAkCA,EAItB,CAChB,GAAI,CACF,GAAM,CAAE,OAAAY,EAAQ,KAAAC,EAAM,QAAAC,CAAQ,EAAId,EAClC,KAAK,MAAM,iBAAiB,CAAE,OAAAY,EAAQ,KAAAC,EAAM,QAAAC,CAAQ,CAAC,CACvD,OAASC,EAAY,CACnB,MAAM,IAAI,MAAM,6CAA6CA,CAAK,EAAE,CACtE,CACF,CAwCA,MAAM,yBACJf,EAIqC,CACrC,OAAOgB,EAAyB,CAC9B,YAAa,KAAK,OAClB,GAAGhB,CACL,CAAC,CACH,CAqBA,MAAM,wBAAwBA,EAIU,CACtC,OAAOiB,EAAwB,CAC7B,YAAa,KAAK,OAClB,GAAGjB,CACL,CAAC,CACH,CACF","names":["Transaction","config","Build","Simulate","Submit","TransactionManagement","args","getTransactions","getTransactionByVersion","getTransactionByHash","isTransactionPending","waitForTransaction","getGasPriceEstimation","getSigningMessage","publicPackageTransaction","rotateAuthKey","signTransaction","signAsFeePayer","sender","data","options","error","signAndSubmitTransaction","signAndSubmitAsFeePayer"]}