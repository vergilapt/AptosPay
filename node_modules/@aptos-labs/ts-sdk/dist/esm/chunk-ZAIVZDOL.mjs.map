{"version":3,"sources":["../../src/account/FederatedKeylessAccount.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { HexInput } from \"../types\";\nimport { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport { getIssAudAndUidVal, Groth16VerificationKey, ZeroKnowledgeSig } from \"../core/crypto\";\n\nimport { EphemeralKeyPair } from \"./EphemeralKeyPair\";\nimport { Deserializer, Serializer } from \"../bcs\";\nimport { FederatedKeylessPublicKey } from \"../core/crypto/federatedKeyless\";\nimport { AbstractKeylessAccount, ProofFetchCallback } from \"./AbstractKeylessAccount\";\n\n/**\n * Account implementation for the FederatedKeyless authentication scheme.\n *\n * Used to represent a FederatedKeyless based account and sign transactions with it.\n *\n * Use `FederatedKeylessAccount.create()` to instantiate a KeylessAccount with a JSON Web Token (JWT), proof, EphemeralKeyPair and the\n * address the JSON Web Key Set (JWKS) are installed that will be used to verify the JWT.\n *\n * When the proof expires or the JWT becomes invalid, the KeylessAccount must be instantiated again with a new JWT,\n * EphemeralKeyPair, and corresponding proof.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport class FederatedKeylessAccount extends AbstractKeylessAccount {\n  /**\n   * The FederatedKeylessPublicKey associated with the account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly publicKey: FederatedKeylessPublicKey;\n\n  readonly audless: boolean;\n\n  /**\n   * Use the static generator `FederatedKeylessAccount.create(...)` instead.\n   * Creates a KeylessAccount instance using the provided parameters.\n   * This function allows you to set up a KeylessAccount with specific attributes such as address, proof, and JWT.\n   *\n   * @param args - The parameters for creating a KeylessAccount.\n   * @param args.address - Optional account address associated with the KeylessAccount.\n   * @param args.proof - A Zero Knowledge Signature or a promise that resolves to one.\n   * @param args.jwt - A JSON Web Token used for authentication.\n   * @param args.ephemeralKeyPair - The ephemeral key pair used in the account creation.\n   * @param args.jwkAddress - The address which stores the JSON Web Key Set (JWKS) used to verify the JWT.\n   * @param args.uidKey - Optional key for user identification, defaults to \"sub\".\n   * @param args.proofFetchCallback - Optional callback function for fetching proof.\n   */\n  constructor(args: {\n    address?: AccountAddress;\n    ephemeralKeyPair: EphemeralKeyPair;\n    iss: string;\n    uidKey: string;\n    uidVal: string;\n    aud: string;\n    pepper: HexInput;\n    jwkAddress: AccountAddress;\n    proof: ZeroKnowledgeSig | Promise<ZeroKnowledgeSig>;\n    proofFetchCallback?: ProofFetchCallback;\n    jwt: string;\n    verificationKeyHash?: HexInput;\n    audless?: boolean;\n  }) {\n    const publicKey = FederatedKeylessPublicKey.create(args);\n    super({ publicKey, ...args });\n    this.publicKey = publicKey;\n    this.audless = args.audless ?? false;\n  }\n\n  /**\n   * Serializes the transaction data into a format suitable for transmission or storage.\n   * This function ensures that both the transaction bytes and the proof are properly serialized.\n   *\n   * @param serializer - The serializer instance used to convert the transaction data into bytes.\n   */\n  serialize(serializer: Serializer): void {\n    super.serialize(serializer);\n    this.publicKey.jwkAddress.serialize(serializer);\n  }\n\n  /**\n   * Deserializes the provided deserializer to create a KeylessAccount instance.\n   * This function extracts necessary components such as the JWT, UID key, pepper, ephemeral key pair, and proof from the deserializer.\n   *\n   * @param deserializer - The deserializer instance used to retrieve the serialized data.\n   * @returns A KeylessAccount instance created from the deserialized data.\n   */\n  static deserialize(deserializer: Deserializer): FederatedKeylessAccount {\n    const { address, proof, ephemeralKeyPair, jwt, uidKey, pepper, verificationKeyHash } =\n      AbstractKeylessAccount.partialDeserialize(deserializer);\n    const jwkAddress = AccountAddress.deserialize(deserializer);\n    const { iss, aud, uidVal } = getIssAudAndUidVal({ jwt, uidKey });\n    return new FederatedKeylessAccount({\n      address,\n      proof,\n      ephemeralKeyPair,\n      iss,\n      uidKey,\n      uidVal,\n      aud,\n      pepper,\n      jwt,\n      verificationKeyHash,\n      jwkAddress,\n    });\n  }\n\n  /**\n   * Deserialize bytes using this account's information.\n   *\n   * @param bytes The bytes being interpreted.\n   * @returns\n   */\n  static fromBytes(bytes: HexInput): FederatedKeylessAccount {\n    return FederatedKeylessAccount.deserialize(Deserializer.fromHex(bytes));\n  }\n\n  /**\n   * Creates a KeylessAccount instance using the provided parameters.\n   * This function allows you to set up a KeylessAccount with specific attributes such as address, proof, and JWT.\n   * This is used instead of the KeylessAccount constructor.\n   *\n   * @param args - The parameters for creating a KeylessAccount.\n   * @param args.address - Optional account address associated with the KeylessAccount.\n   * @param args.proof - A Zero Knowledge Signature or a promise that resolves to one.\n   * @param args.jwt - A JSON Web Token used for authentication.\n   * @param args.ephemeralKeyPair - The ephemeral key pair used in the account creation.\n   * @param args.jwkAddress - The address which stores the JSON Web Key Set (JWKS) used to verify the JWT.\n   * @param args.uidKey - Optional key for user identification, defaults to \"sub\".\n   * @param args.proofFetchCallback - Optional callback function for fetching proof.\n   */\n  static create(args: {\n    address?: AccountAddress;\n    proof: ZeroKnowledgeSig | Promise<ZeroKnowledgeSig>;\n    jwt: string;\n    ephemeralKeyPair: EphemeralKeyPair;\n    pepper: HexInput;\n    jwkAddress: AccountAddressInput;\n    uidKey?: string;\n    proofFetchCallback?: ProofFetchCallback;\n    verificationKey?: Groth16VerificationKey;\n  }): FederatedKeylessAccount {\n    const {\n      address,\n      proof,\n      jwt,\n      ephemeralKeyPair,\n      pepper,\n      jwkAddress,\n      uidKey = \"sub\",\n      proofFetchCallback,\n      verificationKey,\n    } = args;\n\n    const { iss, aud, uidVal } = getIssAudAndUidVal({ jwt, uidKey });\n    return new FederatedKeylessAccount({\n      address,\n      proof,\n      ephemeralKeyPair,\n      iss,\n      uidKey,\n      uidVal,\n      aud,\n      pepper,\n      jwkAddress: AccountAddress.from(jwkAddress),\n      jwt,\n      proofFetchCallback,\n      verificationKeyHash: verificationKey ? verificationKey.hash() : undefined,\n    });\n  }\n}\n"],"mappings":"6MAyBO,IAAMA,EAAN,MAAMC,UAAgCC,CAAuB,CAwBlE,YAAYC,EAcT,CACD,IAAMC,EAAYC,EAA0B,OAAOF,CAAI,EACvD,MAAM,CAAE,UAAAC,EAAW,GAAGD,CAAK,CAAC,EAC5B,KAAK,UAAYC,EACjB,KAAK,QAAUD,EAAK,SAAW,EACjC,CAQA,UAAUG,EAA8B,CACtC,MAAM,UAAUA,CAAU,EAC1B,KAAK,UAAU,WAAW,UAAUA,CAAU,CAChD,CASA,OAAO,YAAYC,EAAqD,CACtE,GAAM,CAAE,QAAAC,EAAS,MAAAC,EAAO,iBAAAC,EAAkB,IAAAC,EAAK,OAAAC,EAAQ,OAAAC,EAAQ,oBAAAC,CAAoB,EACjFZ,EAAuB,mBAAmBK,CAAY,EAClDQ,EAAaC,EAAe,YAAYT,CAAY,EACpD,CAAE,IAAAU,EAAK,IAAAC,EAAK,OAAAC,CAAO,EAAIC,EAAmB,CAAE,IAAAT,EAAK,OAAAC,CAAO,CAAC,EAC/D,OAAO,IAAIX,EAAwB,CACjC,QAAAO,EACA,MAAAC,EACA,iBAAAC,EACA,IAAAO,EACA,OAAAL,EACA,OAAAO,EACA,IAAAD,EACA,OAAAL,EACA,IAAAF,EACA,oBAAAG,EACA,WAAAC,CACF,CAAC,CACH,CAQA,OAAO,UAAUM,EAA0C,CACzD,OAAOpB,EAAwB,YAAYqB,EAAa,QAAQD,CAAK,CAAC,CACxE,CAgBA,OAAO,OAAOlB,EAUc,CAC1B,GAAM,CACJ,QAAAK,EACA,MAAAC,EACA,IAAAE,EACA,iBAAAD,EACA,OAAAG,EACA,WAAAE,EACA,OAAAH,EAAS,MACT,mBAAAW,EACA,gBAAAC,CACF,EAAIrB,EAEE,CAAE,IAAAc,EAAK,IAAAC,EAAK,OAAAC,CAAO,EAAIC,EAAmB,CAAE,IAAAT,EAAK,OAAAC,CAAO,CAAC,EAC/D,OAAO,IAAIX,EAAwB,CACjC,QAAAO,EACA,MAAAC,EACA,iBAAAC,EACA,IAAAO,EACA,OAAAL,EACA,OAAAO,EACA,IAAAD,EACA,OAAAL,EACA,WAAYG,EAAe,KAAKD,CAAU,EAC1C,IAAAJ,EACA,mBAAAY,EACA,oBAAqBC,EAAkBA,EAAgB,KAAK,EAAI,MAClE,CAAC,CACH,CACF","names":["FederatedKeylessAccount","_FederatedKeylessAccount","AbstractKeylessAccount","args","publicKey","FederatedKeylessPublicKey","serializer","deserializer","address","proof","ephemeralKeyPair","jwt","uidKey","pepper","verificationKeyHash","jwkAddress","AccountAddress","iss","aud","uidVal","getIssAudAndUidVal","bytes","Deserializer","proofFetchCallback","verificationKey"]}