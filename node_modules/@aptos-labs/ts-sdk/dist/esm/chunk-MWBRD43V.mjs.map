{"version":3,"sources":["../../src/account/MultiKeyAccount.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Account } from \"./Account\";\nimport { MultiKey, MultiKeySignature, PublicKey } from \"../core/crypto\";\nimport { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport { HexInput, SigningScheme } from \"../types\";\nimport { AccountAuthenticatorMultiKey } from \"../transactions/authenticator/account\";\nimport { AnyRawTransaction } from \"../transactions/types\";\nimport { AbstractKeylessAccount, KeylessSigner } from \"./AbstractKeylessAccount\";\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { SingleKeyAccount, SingleKeySigner, SingleKeySignerOrLegacyEd25519Account } from \"./SingleKeyAccount\";\nimport { Ed25519Account } from \"./Ed25519Account\";\n\n/**\n * Arguments required to verify a multi-key signature against a given message.\n *\n * @param message - The original message that was signed.\n * @param signature - The multi-key signature to be verified.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface VerifyMultiKeySignatureArgs {\n  message: HexInput;\n  signature: MultiKeySignature;\n}\n\n/**\n * Signer implementation for the MultiKey authentication scheme.\n *\n * This account utilizes an M of N signing scheme, where M and N are specified in the {@link MultiKey}.\n * It signs messages using an array of M accounts, each corresponding to a public key in the {@link MultiKey}.\n *\n * Note: Generating a signer instance does not create the account on-chain.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport class MultiKeyAccount implements Account, KeylessSigner {\n  /**\n   * Public key associated with the account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly publicKey: MultiKey;\n\n  /**\n   * Account address associated with the account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly accountAddress: AccountAddress;\n\n  /**\n   * Signing scheme used to sign transactions\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly signingScheme: SigningScheme = SigningScheme.MultiKey;\n\n  /**\n   * The signers used to sign messages.  These signers should correspond to public keys in the\n   * MultiKeyAccount's public key.  The number of signers should be equal or greater\n   * than this.publicKey.signaturesRequired\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly signers: Account[];\n\n  /**\n   * An array of indices where for signer[i], signerIndicies[i] is the index of the corresponding public key in\n   * publicKey.publicKeys.  Used to derive the right public key to use for verification.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  // TODO: Rename Indicies to Indices\n  readonly signerIndicies: number[];\n\n  readonly signaturesBitmap: Uint8Array;\n\n  /**\n   * Constructs a MultiKeyAccount instance, which requires multiple signatures for transactions.\n   *\n   * @param args - The arguments for creating a MultiKeyAccount.\n   * @param args.multiKey - The multikey of the account consisting of N public keys and a number M representing the required signatures.\n   * @param args.signers - An array of M signers that will be used to sign the transaction.\n   * @param args.address - An optional account address input. If not provided, the derived address from the public key will be used.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  constructor(args: {\n    multiKey: MultiKey;\n    signers: SingleKeySignerOrLegacyEd25519Account[];\n    address?: AccountAddressInput;\n  }) {\n    const { multiKey, address } = args;\n\n    const signers: SingleKeySigner[] = args.signers.map((signer) =>\n      signer instanceof Ed25519Account ? SingleKeyAccount.fromEd25519Account(signer) : signer,\n    );\n\n    if (multiKey.signaturesRequired > signers.length) {\n      throw new Error(\n        // eslint-disable-next-line max-len\n        `Not enough signers provided to satisfy the required signatures. Need ${multiKey.signaturesRequired} signers, but only ${signers.length} provided`,\n      );\n    } else if (multiKey.signaturesRequired < signers.length) {\n      throw new Error(\n        // eslint-disable-next-line max-len\n        `More signers provided than required. Need ${multiKey.signaturesRequired} signers, but ${signers.length} provided`,\n      );\n    }\n\n    this.publicKey = multiKey;\n\n    this.accountAddress = address ? AccountAddress.from(address) : this.publicKey.authKey().derivedAddress();\n\n    // For each signer, find its corresponding position in the MultiKey's public keys array\n    const bitPositions: number[] = [];\n    for (const signer of signers) {\n      bitPositions.push(this.publicKey.getIndex(signer.getAnyPublicKey()));\n    }\n\n    // Create pairs of [signer, position] and sort them by position\n    // This sorting is critical because:\n    // 1. The on-chain verification expects signatures to be in ascending order by bit position\n    // 2. The bitmap must match the order of signatures when verifying\n    const signersAndBitPosition: [Account, number][] = signers.map((signer, index) => [signer, bitPositions[index]]);\n    signersAndBitPosition.sort((a, b) => a[1] - b[1]);\n\n    // Extract the sorted signers and their positions into separate arrays\n    this.signers = signersAndBitPosition.map((value) => value[0]);\n    this.signerIndicies = signersAndBitPosition.map((value) => value[1]);\n\n    // Create a bitmap representing which public keys from the MultiKey are being used\n    // This bitmap is used during signature verification to identify which public keys\n    // should be used to verify each signature\n    this.signaturesBitmap = this.publicKey.createBitmap({ bits: bitPositions });\n  }\n\n  /**\n   * Static constructor to create a MultiKeyAccount using the provided public keys and signers.\n   *\n   * @param args - The arguments for creating a MultiKeyAccount.\n   * @param args.publicKeys - The N public keys of the MultiKeyAccount.\n   * @param args.signaturesRequired - The number of signatures required to authorize a transaction.\n   * @param args.signers - An array of M signers that will be used to sign the transaction.\n   * @returns MultiKeyAccount - The newly created MultiKeyAccount.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static fromPublicKeysAndSigners(args: {\n    publicKeys: PublicKey[];\n    signaturesRequired: number;\n    signers: SingleKeySignerOrLegacyEd25519Account[];\n  }): MultiKeyAccount {\n    const { publicKeys, signaturesRequired, signers } = args;\n    const multiKey = new MultiKey({ publicKeys, signaturesRequired });\n    return new MultiKeyAccount({ multiKey, signers });\n  }\n\n  /**\n   * Determines if the provided account is a multi-key account.\n   *\n   * @param account - The account to check.\n   * @returns A boolean indicating whether the account is a multi-key account.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static isMultiKeySigner(account: Account): account is MultiKeyAccount {\n    return account instanceof MultiKeyAccount;\n  }\n\n  /**\n   * Sign a message using the account's signers and return an AccountAuthenticator containing the signature along with the\n   * account's public key.\n   * @param message - The signing message, represented as binary input in hexadecimal format.\n   * @returns An instance of AccountAuthenticatorMultiKey that includes the signature and the public key.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  signWithAuthenticator(message: HexInput): AccountAuthenticatorMultiKey {\n    return new AccountAuthenticatorMultiKey(this.publicKey, this.sign(message));\n  }\n\n  /**\n   * Sign a transaction using the account's signers, returning an AccountAuthenticator that contains the signature and the\n   * account's public key.\n   * @param transaction - The raw transaction to be signed.\n   * @returns An AccountAuthenticatorMultiKey containing the signature of the transaction along with the account's public key.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  signTransactionWithAuthenticator(transaction: AnyRawTransaction): AccountAuthenticatorMultiKey {\n    return new AccountAuthenticatorMultiKey(this.publicKey, this.signTransaction(transaction));\n  }\n\n  /**\n   * Waits for any proofs on KeylessAccount signers to be fetched. This ensures that signing with the KeylessAccount does not\n   * fail due to missing proofs.\n   * @return {Promise<void>} A promise that resolves when all proofs have been fetched.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  async waitForProofFetch(): Promise<void> {\n    const keylessSigners = this.signers.filter(\n      (signer) => signer instanceof AbstractKeylessAccount,\n    ) as AbstractKeylessAccount[];\n    const promises = keylessSigners.map(async (signer) => signer.waitForProofFetch());\n    await Promise.all(promises);\n  }\n\n  /**\n   * Validates that the Keyless Account can be used to sign transactions.\n   * @return\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  async checkKeylessAccountValidity(aptosConfig: AptosConfig): Promise<void> {\n    const keylessSigners = this.signers.filter(\n      (signer) => signer instanceof AbstractKeylessAccount,\n    ) as AbstractKeylessAccount[];\n    const promises = keylessSigners.map((signer) => signer.checkKeylessAccountValidity(aptosConfig));\n    await Promise.all(promises);\n  }\n\n  /**\n   * Sign the given message using the MultiKeyAccount's signers\n   * @param data - The data to be signed in HexInput format.\n   * @returns MultiKeySignature\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  sign(data: HexInput): MultiKeySignature {\n    const signatures = [];\n    for (const signer of this.signers) {\n      signatures.push(signer.sign(data));\n    }\n    return new MultiKeySignature({ signatures, bitmap: this.signaturesBitmap });\n  }\n\n  /**\n   * Sign the given transaction using the MultiKeyAccount's signers.\n   * This function aggregates signatures from all signers associated with the MultiKeyAccount.\n   *\n   * @param transaction - The transaction to be signed.\n   * @returns MultiKeySignature - An object containing the aggregated signatures and a bitmap of the signatures.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  signTransaction(transaction: AnyRawTransaction): MultiKeySignature {\n    const signatures = [];\n    for (const signer of this.signers) {\n      signatures.push(signer.signTransaction(transaction));\n    }\n    return new MultiKeySignature({ signatures, bitmap: this.signaturesBitmap });\n  }\n\n  /**\n   * Verify the given message and signature with the public keys.\n   *\n   * This function checks if the provided signatures are valid for the given message using the corresponding public keys.\n   *\n   * @param args - The arguments for verifying the signature.\n   * @param args.message - The raw message data in HexInput format.\n   * @param args.signature - The signed message MultiKeySignature containing multiple signatures.\n   * @returns A boolean indicating whether the signatures are valid for the message.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  verifySignature(args: VerifyMultiKeySignatureArgs): boolean {\n    const { message, signature } = args;\n    const isSignerIndicesSorted = this.signerIndicies.every(\n      (value, i) => i === 0 || value >= this.signerIndicies[i - 1],\n    );\n    if (!isSignerIndicesSorted) {\n      return false;\n    }\n    for (let i = 0; i < signature.signatures.length; i += 1) {\n      const singleSignature = signature.signatures[i];\n      const publicKey = this.publicKey.publicKeys[this.signerIndicies[i]];\n      if (!publicKey.verifySignature({ message, signature: singleSignature })) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n"],"mappings":"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","names":["MultiKeyAccount","_MultiKeyAccount","args","multiKey","address","signers","signer","Ed25519Account","SingleKeyAccount","AccountAddress","bitPositions","signersAndBitPosition","index","a","b","value","publicKeys","signaturesRequired","MultiKey","account","message","AccountAuthenticatorMultiKey","transaction","promises","AbstractKeylessAccount","aptosConfig","data","signatures","MultiKeySignature","signature","i","singleSignature"]}