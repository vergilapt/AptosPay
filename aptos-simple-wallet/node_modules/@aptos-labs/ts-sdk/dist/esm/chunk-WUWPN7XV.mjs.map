{"version":3,"sources":["../../src/internal/account.ts"],"sourcesContent":["// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/account}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * account namespace and without having a dependency cycle error.\n * @group Implementation\n */\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { getAptosFullNode, paginateWithCursor, paginateWithObfuscatedCursor } from \"../client\";\nimport {\n  AccountData,\n  GetAccountCoinsDataResponse,\n  GetAccountCollectionsWithOwnedTokenResponse,\n  GetAccountOwnedTokensFromCollectionResponse,\n  GetAccountOwnedTokensQueryResponse,\n  GetObjectDataQueryResponse,\n  LedgerVersionArg,\n  MoveModuleBytecode,\n  MoveResource,\n  MoveStructId,\n  OrderByArg,\n  PaginationArgs,\n  TokenStandardArg,\n  TransactionResponse,\n  WhereArg,\n} from \"../types\";\nimport { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport { Account } from \"../account\";\nimport { AnyPublicKey, Ed25519PublicKey, PrivateKey } from \"../core/crypto\";\nimport { queryIndexer } from \"./general\";\nimport {\n  GetAccountCoinsCountQuery,\n  GetAccountCoinsDataQuery,\n  GetAccountCollectionsWithOwnedTokensQuery,\n  GetObjectDataQuery,\n  GetAccountOwnedTokensFromCollectionQuery,\n  GetAccountOwnedTokensQuery,\n  GetAccountTokensCountQuery,\n  GetAccountTransactionsCountQuery,\n} from \"../types/generated/operations\";\nimport {\n  GetAccountCoinsCount,\n  GetAccountCoinsData,\n  GetAccountCollectionsWithOwnedTokens,\n  GetObjectData,\n  GetAccountOwnedTokens,\n  GetAccountOwnedTokensFromCollection,\n  GetAccountTokensCount,\n  GetAccountTransactionsCount,\n} from \"../types/generated/queries\";\nimport { memoizeAsync } from \"../utils/memoize\";\nimport { Secp256k1PrivateKey, AuthenticationKey, Ed25519PrivateKey, createObjectAddress } from \"../core\";\nimport { CurrentFungibleAssetBalancesBoolExp } from \"../types/generated/types\";\nimport { getTableItem } from \"./table\";\nimport { APTOS_COIN } from \"../utils\";\nimport { AptosApiError } from \"../errors\";\n\n/**\n * Retrieves account information for a specified account address.\n *\n * @param args - The arguments for retrieving account information.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.accountAddress - The address of the account to retrieve information for.\n * @group Implementation\n */\nexport async function getInfo(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n}): Promise<AccountData> {\n  const { aptosConfig, accountAddress } = args;\n  const { data } = await getAptosFullNode<{}, AccountData>({\n    aptosConfig,\n    originMethod: \"getInfo\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}`,\n  });\n  return data;\n}\n\n/**\n * Retrieves the modules associated with a specified account address.\n *\n * @param args - The arguments for retrieving modules.\n * @param args.aptosConfig - The configuration for connecting to the Aptos blockchain.\n * @param args.accountAddress - The address of the account whose modules are to be retrieved.\n * @param args.options - Optional parameters for pagination and ledger version.\n * @param args.options.limit - The maximum number of modules to retrieve (default is 1000).\n * @param args.options.offset - The starting point for pagination.  Note, this is obfuscated and is not an index.\n * @param args.options.ledgerVersion - The specific ledger version to query.\n * @group Implementation\n */\nexport async function getModules(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgs & LedgerVersionArg;\n}): Promise<MoveModuleBytecode[]> {\n  const { aptosConfig, accountAddress, options } = args;\n  return paginateWithObfuscatedCursor<{}, MoveModuleBytecode[]>({\n    aptosConfig,\n    originMethod: \"getModules\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/modules`,\n    params: {\n      ledger_version: options?.ledgerVersion,\n      offset: options?.offset,\n      limit: options?.limit ?? 1000,\n    },\n  });\n}\n\n/**\n * Queries for a move module given an account address and module name.\n * This function can help you retrieve the module's ABI and other relevant information.\n *\n * @param args - The arguments for retrieving the module.\n * @param args.aptosConfig - The configuration for the Aptos client.\n * @param args.accountAddress - The account address in hex-encoded 32 byte format.\n * @param args.moduleName - The name of the module to retrieve.\n * @param args.options - Optional parameters for the request.\n * @param args.options.ledgerVersion - Specifies the ledger version of transactions. By default, the latest version will be used.\n * @returns The move module.\n * @group Implementation\n */\nexport async function getModule(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  moduleName: string;\n  options?: LedgerVersionArg;\n}): Promise<MoveModuleBytecode> {\n  // We don't memoize the account module by ledger version, as it's not a common use case, this would be handled\n  // by the developer directly\n  if (args.options?.ledgerVersion !== undefined) {\n    return getModuleInner(args);\n  }\n\n  return memoizeAsync(\n    async () => getModuleInner(args),\n    `module-${args.accountAddress}-${args.moduleName}`,\n    1000 * 60 * 5, // 5 minutes\n  )();\n}\n\n/**\n * Retrieves the bytecode of a specified module from a given account address.\n *\n * @param args - The parameters for retrieving the module bytecode.\n * @param args.aptosConfig - The configuration for connecting to the Aptos network.\n * @param args.accountAddress - The address of the account from which to retrieve the module.\n * @param args.moduleName - The name of the module to retrieve.\n * @param args.options - Optional parameters for specifying the ledger version.\n * @param args.options.ledgerVersion - The specific ledger version to query.\n * @group Implementation\n */\nasync function getModuleInner(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  moduleName: string;\n  options?: LedgerVersionArg;\n}): Promise<MoveModuleBytecode> {\n  const { aptosConfig, accountAddress, moduleName, options } = args;\n\n  const { data } = await getAptosFullNode<{}, MoveModuleBytecode>({\n    aptosConfig,\n    originMethod: \"getModule\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/module/${moduleName}`,\n    params: { ledger_version: options?.ledgerVersion },\n  });\n  return data;\n}\n\n/**\n * Retrieves a list of transactions associated with a specific account address.\n * This function allows you to paginate through the transactions for better performance and usability.\n *\n * @param args - The arguments for retrieving transactions.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.accountAddress - The account address for which to retrieve transactions.\n * @param args.options - Optional pagination parameters.\n * @param args.options.offset - The starting point for pagination.\n * @param args.options.limit - The maximum number of transactions to retrieve.\n * @group Implementation\n */\nexport async function getTransactions(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgs;\n}): Promise<TransactionResponse[]> {\n  const { aptosConfig, accountAddress, options } = args;\n  return paginateWithCursor<{}, TransactionResponse[]>({\n    aptosConfig,\n    originMethod: \"getTransactions\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/transactions`,\n    params: { start: options?.offset, limit: options?.limit },\n  });\n}\n\n/**\n * Retrieves a list of resources associated with a specific account address.\n *\n * @param args - The arguments for retrieving resources.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.accountAddress - The address of the account to fetch resources for.\n * @param args.options - Optional pagination and ledger version parameters.\n * @param args.options.offset - The starting point for pagination.  Note, this is obfuscated and is not an index.\n * @param args.options.limit - The maximum number of resources to retrieve (default is 999).\n * @param args.options.ledgerVersion - The specific ledger version to query.\n * @group Implementation\n */\nexport async function getResources(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgs & LedgerVersionArg;\n}): Promise<MoveResource[]> {\n  const { aptosConfig, accountAddress, options } = args;\n  return paginateWithObfuscatedCursor<{}, MoveResource[]>({\n    aptosConfig,\n    originMethod: \"getResources\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/resources`,\n    params: {\n      ledger_version: options?.ledgerVersion,\n      offset: options?.offset,\n      limit: options?.limit ?? 999,\n    },\n  });\n}\n\n/**\n * Retrieves a specific resource of a given type for the specified account address.\n *\n * @param args - The arguments for retrieving the resource.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.accountAddress - The address of the account from which to retrieve the resource.\n * @param args.resourceType - The type of the resource to retrieve, specified as a MoveStructId.\n * @param args.options - Optional parameters for specifying the ledger version.\n * @group Implementation\n */\nexport async function getResource<T extends {}>(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  resourceType: MoveStructId;\n  options?: LedgerVersionArg;\n}): Promise<T> {\n  const { aptosConfig, accountAddress, resourceType, options } = args;\n  const { data } = await getAptosFullNode<{}, MoveResource>({\n    aptosConfig,\n    originMethod: \"getResource\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/resource/${resourceType}`,\n    params: { ledger_version: options?.ledgerVersion },\n  });\n  return data.data as T;\n}\n\n/**\n * Retrieves the original account address associated with a given authentication key, which is useful for handling key rotations.\n *\n * @param args - The arguments for the lookup.\n * @param args.aptosConfig - The configuration for the Aptos client.\n * @param args.authenticationKey - The authentication key for which to look up the original address.\n * @param args.options - Optional parameters for specifying the ledger version.\n * @returns The original account address or the provided authentication key address if not found.\n * @throws Throws an error if the lookup fails for reasons other than the address not being found.\n * @group Implementation\n */\nexport async function lookupOriginalAccountAddress(args: {\n  aptosConfig: AptosConfig;\n  authenticationKey: AccountAddressInput;\n  options?: LedgerVersionArg;\n}): Promise<AccountAddress> {\n  const { aptosConfig, authenticationKey, options } = args;\n  type OriginatingAddress = {\n    address_map: { handle: string };\n  };\n  const resource = await getResource<OriginatingAddress>({\n    aptosConfig,\n    accountAddress: \"0x1\",\n    resourceType: \"0x1::account::OriginatingAddress\",\n    options,\n  });\n\n  const {\n    address_map: { handle },\n  } = resource;\n\n  const authKeyAddress = AccountAddress.from(authenticationKey);\n\n  // If the address is not found in the address map, which means its not rotated\n  // then return the address as is\n  try {\n    const originalAddress = await getTableItem<string>({\n      aptosConfig,\n      handle,\n      data: {\n        key: authKeyAddress.toString(),\n        key_type: \"address\",\n        value_type: \"address\",\n      },\n      options,\n    });\n\n    return AccountAddress.from(originalAddress);\n  } catch (err) {\n    if (err instanceof AptosApiError && err.data.error_code === \"table_item_not_found\") {\n      return authKeyAddress;\n    }\n\n    throw err;\n  }\n}\n\n/**\n * Retrieves the count of tokens owned by a specific account address.\n *\n * @param args - The arguments for retrieving the account tokens count.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.accountAddress - The address of the account for which to count the tokens.\n * @returns The count of tokens owned by the specified account.\n * @group Implementation\n */\nexport async function getAccountTokensCount(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n}): Promise<number> {\n  const { aptosConfig, accountAddress } = args;\n\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: { owner_address: { _eq: string }; amount: { _gt: number } } = {\n    owner_address: { _eq: address },\n    amount: { _gt: 0 },\n  };\n\n  const graphqlQuery = {\n    query: GetAccountTokensCount,\n    variables: { where_condition: whereCondition },\n  };\n\n  const data = await queryIndexer<GetAccountTokensCountQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountTokensCount\",\n  });\n\n  // commonjs (aka cjs) doesn't handle Nullish Coalescing for some reason\n  // might be because of how ts infer the graphql generated scheme type\n  return data.current_token_ownerships_v2_aggregate.aggregate\n    ? data.current_token_ownerships_v2_aggregate.aggregate.count\n    : 0;\n}\n\n/**\n * Retrieves the tokens owned by a specified account address.\n *\n * @param args - The arguments for retrieving the account's tokens.\n * @param args.aptosConfig - The configuration for the Aptos client.\n * @param args.accountAddress - The address of the account whose tokens are being queried.\n * @param args.options - Optional parameters for filtering and pagination.\n * @param args.options.tokenStandard - The specific token standard to filter the results.\n * @param args.options.offset - The number of records to skip before starting to collect the result set.\n * @param args.options.limit - The maximum number of records to return.\n * @param args.options.orderBy - The criteria for ordering the results.\n * @returns A promise that resolves to the current token ownerships of the specified account.\n * @group Implementation\n */\nexport async function getAccountOwnedTokens(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountOwnedTokensQueryResponse[0]>;\n}): Promise<GetAccountOwnedTokensQueryResponse> {\n  const { aptosConfig, accountAddress, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: { owner_address: { _eq: string }; amount: { _gt: number }; token_standard?: { _eq: string } } =\n    {\n      owner_address: { _eq: address },\n      amount: { _gt: 0 },\n    };\n\n  if (options?.tokenStandard) {\n    whereCondition.token_standard = { _eq: options?.tokenStandard };\n  }\n\n  const graphqlQuery = {\n    query: GetAccountOwnedTokens,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountOwnedTokensQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountOwnedTokens\",\n  });\n\n  return data.current_token_ownerships_v2;\n}\n\n/**\n * Retrieves the tokens owned by a specific account from a particular collection address.\n *\n * @param args - The parameters required to fetch the owned tokens.\n * @param args.aptosConfig - The Aptos configuration object.\n * @param args.accountAddress - The address of the account whose tokens are being queried.\n * @param args.collectionAddress - The address of the collection from which tokens are being retrieved.\n * @param args.options - Optional parameters for filtering and pagination, including token standard, pagination arguments, and\n * order by options.\n * @group Implementation\n */\nexport async function getAccountOwnedTokensFromCollectionAddress(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  collectionAddress: AccountAddressInput;\n  options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountOwnedTokensFromCollectionResponse[0]>;\n}): Promise<GetAccountOwnedTokensFromCollectionResponse> {\n  const { aptosConfig, accountAddress, collectionAddress, options } = args;\n  const ownerAddress = AccountAddress.from(accountAddress).toStringLong();\n  const collAddress = AccountAddress.from(collectionAddress).toStringLong();\n\n  const whereCondition: {\n    owner_address: { _eq: string };\n    current_token_data: { collection_id: { _eq: string } };\n    amount: { _gt: number };\n    token_standard?: { _eq: string };\n  } = {\n    owner_address: { _eq: ownerAddress },\n    current_token_data: { collection_id: { _eq: collAddress } },\n    amount: { _gt: 0 },\n  };\n\n  if (options?.tokenStandard) {\n    whereCondition.token_standard = { _eq: options?.tokenStandard };\n  }\n\n  const graphqlQuery = {\n    query: GetAccountOwnedTokensFromCollection,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountOwnedTokensFromCollectionQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountOwnedTokensFromCollectionAddress\",\n  });\n\n  return data.current_token_ownerships_v2;\n}\n\n/**\n * Retrieves the collections owned by a specified account along with the tokens in those collections.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration for the Aptos client.\n * @param args.accountAddress - The address of the account whose collections are being queried.\n * @param args.options - Optional parameters for filtering and pagination.\n * @param args.options.tokenStandard - An optional token standard to filter the collections.\n * @param args.options.offset - An optional offset for pagination.\n * @param args.options.limit - An optional limit for the number of results returned.\n * @param args.options.orderBy - An optional parameter to specify the order of the results.\n * @group Implementation\n */\nexport async function getAccountCollectionsWithOwnedTokens(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountCollectionsWithOwnedTokenResponse[0]>;\n}): Promise<GetAccountCollectionsWithOwnedTokenResponse> {\n  const { aptosConfig, accountAddress, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: {\n    owner_address: { _eq: string };\n    current_collection?: { token_standard: { _eq: string } };\n  } = {\n    owner_address: { _eq: address },\n  };\n\n  if (options?.tokenStandard) {\n    whereCondition.current_collection = {\n      token_standard: { _eq: options?.tokenStandard },\n    };\n  }\n\n  const graphqlQuery = {\n    query: GetAccountCollectionsWithOwnedTokens,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountCollectionsWithOwnedTokensQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountCollectionsWithOwnedTokens\",\n  });\n\n  return data.current_collection_ownership_v2_view;\n}\n\n/**\n * Retrieves the count of transactions associated with a specified account.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.accountAddress - The address of the account for which to retrieve the transaction count.\n * @returns The number of transactions associated with the specified account.\n * @group Implementation\n */\nexport async function getAccountTransactionsCount(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n}): Promise<number> {\n  const { aptosConfig, accountAddress } = args;\n\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const graphqlQuery = {\n    query: GetAccountTransactionsCount,\n    variables: { address },\n  };\n\n  const data = await queryIndexer<GetAccountTransactionsCountQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountTransactionsCount\",\n  });\n\n  // commonjs (aka cjs) doesn't handle Nullish Coalescing for some reason\n  // might be because of how ts infer the graphql generated scheme type\n  return data.account_transactions_aggregate.aggregate ? data.account_transactions_aggregate.aggregate.count : 0;\n}\n\n/**\n * Retrieves the amount of a specific coin held by an account.\n *\n * @param args - The parameters for the request.\n * @param args.aptosConfig - The Aptos configuration object.\n * @param args.accountAddress - The address of the account to query.\n * @param args.coinType - Optional; the type of coin to check the amount for.\n * @param args.faMetadataAddress - Optional; the address of the fungible asset metadata.\n * @returns The amount of the specified coin held by the account, or 0 if none is found.\n * @throws Error if neither coinType nor faMetadataAddress is provided.\n * @group Implementation\n */\nexport async function getAccountCoinAmount(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  coinType?: MoveStructId;\n  faMetadataAddress?: AccountAddressInput;\n}): Promise<number> {\n  const { aptosConfig, accountAddress, coinType, faMetadataAddress } = args;\n\n  let coinAssetType: string | undefined = coinType;\n  let faAddress: string;\n\n  if (coinType !== undefined && faMetadataAddress !== undefined) {\n    faAddress = AccountAddress.from(faMetadataAddress).toStringLong();\n  } else if (coinType !== undefined && faMetadataAddress === undefined) {\n    // TODO Move to a separate function as defined in the AIP for coin migration\n    if (coinType === APTOS_COIN) {\n      faAddress = AccountAddress.A.toStringLong();\n    } else {\n      faAddress = createObjectAddress(AccountAddress.A, coinType).toStringLong();\n    }\n  } else if (coinType === undefined && faMetadataAddress !== undefined) {\n    const addr = AccountAddress.from(faMetadataAddress);\n    faAddress = addr.toStringLong();\n    if (addr === AccountAddress.A) {\n      coinAssetType = APTOS_COIN;\n    }\n    // The paired CoinType should be populated outside of this function in another\n    // async call. We cannot do this internally due to dependency cycles issue.\n  } else {\n    throw new Error(\"Either coinType, fungibleAssetAddress, or both must be provided\");\n  }\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  // Search by fungible asset address, unless it has a coin it migrated from\n  let where: any = { asset_type: { _eq: faAddress } };\n  if (coinAssetType !== undefined) {\n    where = { asset_type: { _in: [coinAssetType, faAddress] } };\n  }\n\n  const data = await getAccountCoinsData({\n    aptosConfig,\n    accountAddress: address,\n    options: {\n      where,\n    },\n  });\n\n  // commonjs (aka cjs) doesn't handle Nullish Coalescing for some reason\n  // might be because of how ts infer the graphql generated scheme type\n  return data[0] ? data[0].amount : 0;\n}\n\n/**\n * Retrieves the current fungible asset balances for a specified account.\n *\n * @param args - The arguments for retrieving account coins data.\n * @param args.aptosConfig - The configuration for connecting to the Aptos network.\n * @param args.accountAddress - The address of the account for which to retrieve coin data.\n * @param args.options - Optional parameters for pagination and filtering the results.\n * @param args.options.offset - The number of items to skip before starting to collect the result set.\n * @param args.options.limit - The maximum number of items to return.\n * @param args.options.orderBy - The criteria for ordering the results.\n * @param args.options.where - Conditions to filter the results based on the current fungible asset balances.\n * @group Implementation\n */\nexport async function getAccountCoinsData(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgs & OrderByArg<GetAccountCoinsDataResponse[0]> & WhereArg<CurrentFungibleAssetBalancesBoolExp>;\n}): Promise<GetAccountCoinsDataResponse> {\n  const { aptosConfig, accountAddress, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: { owner_address: { _eq: string } } = {\n    ...options?.where,\n    owner_address: { _eq: address },\n  };\n\n  const graphqlQuery = {\n    query: GetAccountCoinsData,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountCoinsDataQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountCoinsData\",\n  });\n\n  return data.current_fungible_asset_balances;\n}\n\n/**\n * Retrieves the count of fungible asset coins held by a specified account.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.accountAddress - The address of the account for which to retrieve the coin count.\n * @throws Error if the count of account coins cannot be retrieved.\n * @group Implementation\n */\nexport async function getAccountCoinsCount(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n}): Promise<number> {\n  const { aptosConfig, accountAddress } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const graphqlQuery = {\n    query: GetAccountCoinsCount,\n    variables: { address },\n  };\n\n  const data = await queryIndexer<GetAccountCoinsCountQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountCoinsCount\",\n  });\n\n  if (!data.current_fungible_asset_balances_aggregate.aggregate) {\n    throw Error(\"Failed to get the count of account coins\");\n  }\n\n  return data.current_fungible_asset_balances_aggregate.aggregate.count;\n}\n\n/**\n * Retrieves the objects owned by a specified account.\n *\n * @param args - The parameters for the request.\n * @param args.aptosConfig - The configuration for the Aptos client.\n * @param args.accountAddress - The address of the account whose owned objects are to be retrieved.\n * @param args.options - Optional parameters for pagination and ordering of the results.\n * @param args.options.offset - The number of items to skip before starting to collect the result set.\n * @param args.options.limit - The maximum number of items to return.\n * @param args.options.orderBy - The criteria to order the results by.\n * @returns A promise that resolves to the current objects owned by the specified account.\n * @group Implementation\n */\nexport async function getAccountOwnedObjects(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgs & OrderByArg<GetObjectDataQueryResponse[0]>;\n}): Promise<GetObjectDataQueryResponse> {\n  const { aptosConfig, accountAddress, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: { owner_address: { _eq: string } } = {\n    owner_address: { _eq: address },\n  };\n  const graphqlQuery = {\n    query: GetObjectData,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n  const data = await queryIndexer<GetObjectDataQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountOwnedObjects\",\n  });\n\n  return data.current_objects;\n}\n\n/**\n * Derives an account from the provided private key and Aptos configuration.\n * This function helps in obtaining the account details associated with a given private key,\n * considering both unified and legacy authentication schemes.\n *\n * NOTE: There is a potential issue once the unified single signer scheme is adopted by the community.\n * Because one could create two accounts with the same private key with this new authenticator type,\n * we’ll need to determine the order in which we look up the accounts: first unified scheme and then legacy scheme,\n * or first legacy scheme and then unified scheme.\n *\n * @param args - The arguments for deriving the account.\n * @param args.aptosConfig - The Aptos configuration used for account lookup.\n * @param args.privateKey - The private key used to derive the account.\n * @throws Error if the account cannot be derived from the private key.\n * @group Implementation\n */\nexport async function deriveAccountFromPrivateKey(args: {\n  aptosConfig: AptosConfig;\n  privateKey: PrivateKey;\n}): Promise<Account> {\n  const { aptosConfig, privateKey } = args;\n  const publicKey = new AnyPublicKey(privateKey.publicKey());\n\n  if (privateKey instanceof Secp256k1PrivateKey) {\n    // private key is secp256k1, therefore we know it for sure uses a single signer key\n    const authKey = AuthenticationKey.fromPublicKey({ publicKey });\n    const address = authKey.derivedAddress();\n    return Account.fromPrivateKey({ privateKey, address });\n  }\n\n  if (privateKey instanceof Ed25519PrivateKey) {\n    // lookup single sender ed25519\n    const singleSenderTransactionAuthenticatorAuthKey = AuthenticationKey.fromPublicKey({\n      publicKey,\n    });\n    const isSingleSenderTransactionAuthenticator = await isAccountExist({\n      authKey: singleSenderTransactionAuthenticatorAuthKey,\n      aptosConfig,\n    });\n    if (isSingleSenderTransactionAuthenticator) {\n      const address = singleSenderTransactionAuthenticatorAuthKey.derivedAddress();\n      return Account.fromPrivateKey({ privateKey, address, legacy: false });\n    }\n    // lookup legacy ed25519\n    const legacyAuthKey = AuthenticationKey.fromPublicKey({\n      publicKey: publicKey.publicKey as Ed25519PublicKey,\n    });\n    const isLegacyEd25519 = await isAccountExist({ authKey: legacyAuthKey, aptosConfig });\n    if (isLegacyEd25519) {\n      const address = legacyAuthKey.derivedAddress();\n      return Account.fromPrivateKey({ privateKey, address, legacy: true });\n    }\n  }\n  // if we are here, it means we couldn't find an address with an\n  // auth key that matches the provided private key\n  throw new Error(`Can't derive account from private key ${privateKey}`);\n}\n\n/**\n * Checks if an account exists by verifying its information against the Aptos blockchain.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration for connecting to the Aptos blockchain.\n * @param args.authKey - The authentication key used to derive the account address.\n * @returns A promise that resolves to a boolean indicating whether the account exists.\n *\n * @throws Throws an Error if there is an issue while looking for account information.\n * @group Implementation\n */\nexport async function isAccountExist(args: { aptosConfig: AptosConfig; authKey: AuthenticationKey }): Promise<boolean> {\n  const { aptosConfig, authKey } = args;\n  const accountAddress = await lookupOriginalAccountAddress({\n    aptosConfig,\n    authenticationKey: authKey.derivedAddress(),\n  });\n\n  try {\n    await getInfo({\n      aptosConfig,\n      accountAddress,\n    });\n    return true;\n  } catch (error: any) {\n    // account not found\n    if (error.status === 404) {\n      return false;\n    }\n    throw new Error(`Error while looking for an account info ${accountAddress.toString()}`);\n  }\n}\n"],"mappings":"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","names":["getInfo","args","aptosConfig","accountAddress","data","getAptosFullNode","AccountAddress","getModules","options","paginateWithObfuscatedCursor","getModule","getModuleInner","memoizeAsync","moduleName","getTransactions","paginateWithCursor","getResources","getResource","resourceType","lookupOriginalAccountAddress","authenticationKey","resource","handle","authKeyAddress","originalAddress","getTableItem","err","AptosApiError","getAccountTokensCount","whereCondition","queryIndexer","GetAccountTokensCount","getAccountOwnedTokens","graphqlQuery","GetAccountOwnedTokens","getAccountOwnedTokensFromCollectionAddress","collectionAddress","ownerAddress","collAddress","GetAccountOwnedTokensFromCollection","getAccountCollectionsWithOwnedTokens","GetAccountCollectionsWithOwnedTokens","getAccountTransactionsCount","address","GetAccountTransactionsCount","getAccountCoinAmount","coinType","faMetadataAddress","coinAssetType","faAddress","APTOS_COIN","createObjectAddress","addr","where","getAccountCoinsData","GetAccountCoinsData","getAccountCoinsCount","GetAccountCoinsCount","getAccountOwnedObjects","GetObjectData","deriveAccountFromPrivateKey","privateKey","publicKey","AnyPublicKey","Secp256k1PrivateKey","AuthenticationKey","Account","Ed25519PrivateKey","singleSenderTransactionAuthenticatorAuthKey","isAccountExist","legacyAuthKey","authKey","error"]}