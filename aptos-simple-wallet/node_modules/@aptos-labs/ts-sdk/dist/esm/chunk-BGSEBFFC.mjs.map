{"version":3,"sources":["../../src/core/crypto/federatedKeyless.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AccountPublicKey, PublicKey } from \"./publicKey\";\nimport { Deserializer, Serializer } from \"../../bcs\";\nimport { HexInput, AnyPublicKeyVariant, SigningScheme } from \"../../types\";\nimport { AuthenticationKey } from \"../authenticationKey\";\nimport { AccountAddress, AccountAddressInput } from \"../accountAddress\";\nimport { KeylessPublicKey, KeylessSignature } from \"./keyless\";\n\n/**\n * Represents the FederatedKeylessPublicKey public key\n *\n * These keys use an on-chain address as a source of truth for the JWK used to verify signatures.\n *\n * FederatedKeylessPublicKey authentication key is represented in the SDK as `AnyPublicKey`.\n * @group Implementation\n * @category Serialization\n */\nexport class FederatedKeylessPublicKey extends AccountPublicKey {\n  /**\n   * The address that contains the JWK set to be used for verification.\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly jwkAddress: AccountAddress;\n\n  /**\n   * The inner public key which contains the standard Keyless public key.\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly keylessPublicKey: KeylessPublicKey;\n\n  constructor(jwkAddress: AccountAddressInput, keylessPublicKey: KeylessPublicKey) {\n    super();\n    this.jwkAddress = AccountAddress.from(jwkAddress);\n    this.keylessPublicKey = keylessPublicKey;\n  }\n\n  /**\n   * Get the authentication key for the federated keyless public key\n   *\n   * @returns AuthenticationKey\n   * @group Implementation\n   * @category Serialization\n   */\n  authKey(): AuthenticationKey {\n    const serializer = new Serializer();\n    serializer.serializeU32AsUleb128(AnyPublicKeyVariant.FederatedKeyless);\n    serializer.serializeFixedBytes(this.bcsToBytes());\n    return AuthenticationKey.fromSchemeAndBytes({\n      scheme: SigningScheme.SingleKey,\n      input: serializer.toUint8Array(),\n    });\n  }\n\n  /**\n   * Verifies a signed data with a public key\n   *\n   * @param args.message message\n   * @param args.signature The signature\n   * @returns true if the signature is valid\n   * @group Implementation\n   * @category Serialization\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars, class-methods-use-this\n  verifySignature(args: { message: HexInput; signature: KeylessSignature }): boolean {\n    throw new Error(\"Not yet implemented\");\n  }\n\n  serialize(serializer: Serializer): void {\n    this.jwkAddress.serialize(serializer);\n    this.keylessPublicKey.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): FederatedKeylessPublicKey {\n    const jwkAddress = AccountAddress.deserialize(deserializer);\n    const keylessPublicKey = KeylessPublicKey.deserialize(deserializer);\n    return new FederatedKeylessPublicKey(jwkAddress, keylessPublicKey);\n  }\n\n  static isPublicKey(publicKey: PublicKey): publicKey is FederatedKeylessPublicKey {\n    return publicKey instanceof FederatedKeylessPublicKey;\n  }\n\n  /**\n   * Creates a FederatedKeylessPublicKey from the JWT components plus pepper\n   *\n   * @param args.iss the iss of the identity\n   * @param args.uidKey the key to use to get the uidVal in the JWT token\n   * @param args.uidVal the value of the uidKey in the JWT token\n   * @param args.aud the client ID of the application\n   * @param args.pepper The pepper used to maintain privacy of the account\n   * @returns FederatedKeylessPublicKey\n   * @group Implementation\n   * @category Serialization\n   */\n  static create(args: {\n    iss: string;\n    uidKey: string;\n    uidVal: string;\n    aud: string;\n    pepper: HexInput;\n    jwkAddress: AccountAddressInput;\n  }): FederatedKeylessPublicKey {\n    return new FederatedKeylessPublicKey(args.jwkAddress, KeylessPublicKey.create(args));\n  }\n\n  static fromJwtAndPepper(args: {\n    jwt: string;\n    pepper: HexInput;\n    jwkAddress: AccountAddressInput;\n    uidKey?: string;\n  }): FederatedKeylessPublicKey {\n    return new FederatedKeylessPublicKey(args.jwkAddress, KeylessPublicKey.fromJwtAndPepper(args));\n  }\n\n  static isInstance(publicKey: PublicKey) {\n    return (\n      \"jwkAddress\" in publicKey &&\n      publicKey.jwkAddress instanceof AccountAddress &&\n      \"keylessPublicKey\" in publicKey &&\n      publicKey.keylessPublicKey instanceof KeylessPublicKey\n    );\n  }\n}\n"],"mappings":"6MAmBO,IAAMA,EAAN,MAAMC,UAAkCC,CAAiB,CAe9D,YAAYC,EAAiCC,EAAoC,CAC/E,MAAM,EACN,KAAK,WAAaC,EAAe,KAAKF,CAAU,EAChD,KAAK,iBAAmBC,CAC1B,CASA,SAA6B,CAC3B,IAAME,EAAa,IAAIC,EACvB,OAAAD,EAAW,uBAA0D,EACrEA,EAAW,oBAAoB,KAAK,WAAW,CAAC,EACzCE,EAAkB,mBAAmB,CAC1C,SACA,MAAOF,EAAW,aAAa,CACjC,CAAC,CACH,CAYA,gBAAgBG,EAAmE,CACjF,MAAM,IAAI,MAAM,qBAAqB,CACvC,CAEA,UAAUH,EAA8B,CACtC,KAAK,WAAW,UAAUA,CAAU,EACpC,KAAK,iBAAiB,UAAUA,CAAU,CAC5C,CAEA,OAAO,YAAYI,EAAuD,CACxE,IAAMP,EAAaE,EAAe,YAAYK,CAAY,EACpDN,EAAmBO,EAAiB,YAAYD,CAAY,EAClE,OAAO,IAAIT,EAA0BE,EAAYC,CAAgB,CACnE,CAEA,OAAO,YAAYQ,EAA8D,CAC/E,OAAOA,aAAqBX,CAC9B,CAcA,OAAO,OAAOQ,EAOgB,CAC5B,OAAO,IAAIR,EAA0BQ,EAAK,WAAYE,EAAiB,OAAOF,CAAI,CAAC,CACrF,CAEA,OAAO,iBAAiBA,EAKM,CAC5B,OAAO,IAAIR,EAA0BQ,EAAK,WAAYE,EAAiB,iBAAiBF,CAAI,CAAC,CAC/F,CAEA,OAAO,WAAWG,EAAsB,CACtC,MACE,eAAgBA,GAChBA,EAAU,sBAAsBP,GAChC,qBAAsBO,GACtBA,EAAU,4BAA4BD,CAE1C,CACF","names":["FederatedKeylessPublicKey","_FederatedKeylessPublicKey","AccountPublicKey","jwkAddress","keylessPublicKey","AccountAddress","serializer","Serializer","AuthenticationKey","args","deserializer","KeylessPublicKey","publicKey"]}