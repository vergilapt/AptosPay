{"version":3,"sources":["../../src/account/KeylessAccount.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { HexInput } from \"../types\";\nimport { AccountAddress } from \"../core/accountAddress\";\nimport { getIssAudAndUidVal, Groth16VerificationKey, KeylessPublicKey, ZeroKnowledgeSig } from \"../core/crypto\";\n\nimport { EphemeralKeyPair } from \"./EphemeralKeyPair\";\nimport { Deserializer, Serializer } from \"../bcs\";\nimport { AbstractKeylessAccount, ProofFetchCallback } from \"./AbstractKeylessAccount\";\nimport { Hex } from \"../core/hex\";\n\n/**\n * Account implementation for the Keyless authentication scheme.\n *\n * Used to represent a Keyless based account and sign transactions with it.\n *\n * Use `KeylessAccount.create()` to instantiate a KeylessAccount with a JWT, proof and EphemeralKeyPair.\n *\n * When the proof expires or the JWT becomes invalid, the KeylessAccount must be instantiated again with a new JWT,\n * EphemeralKeyPair, and corresponding proof.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport class KeylessAccount extends AbstractKeylessAccount {\n  /**\n   * The KeylessPublicKey associated with the account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly publicKey: KeylessPublicKey;\n\n  // Use the static constructor 'create' instead.\n\n  /**\n   * Use the static generator `create(...)` instead.\n   * Creates an instance of the KeylessAccount with an optional proof.\n   *\n   * @param args - The parameters for creating a KeylessAccount.\n   * @param args.address - Optional account address associated with the KeylessAccount.\n   * @param args.ephemeralKeyPair - The ephemeral key pair used in the account creation.\n   * @param args.iss - A JWT issuer.\n   * @param args.uidKey - The claim on the JWT to identify a user.  This is typically 'sub' or 'email'.\n   * @param args.uidVal - The unique id for this user, intended to be a stable user identifier.\n   * @param args.aud - The value of the 'aud' claim on the JWT, also known as client ID.  This is the identifier for the dApp's\n   * OIDC registration with the identity provider.\n   * @param args.pepper - A hexadecimal input used for additional security.\n   * @param args.proof - A Zero Knowledge Signature or a promise that resolves to one.\n   * @param args.proofFetchCallback - Optional callback function for fetching proof.\n   * @param args.jwt - A JSON Web Token used for authentication.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  constructor(args: {\n    address?: AccountAddress;\n    ephemeralKeyPair: EphemeralKeyPair;\n    iss: string;\n    uidKey: string;\n    uidVal: string;\n    aud: string;\n    pepper: HexInput;\n    proof: ZeroKnowledgeSig | Promise<ZeroKnowledgeSig>;\n    proofFetchCallback?: ProofFetchCallback;\n    jwt: string;\n    verificationKeyHash?: HexInput;\n  }) {\n    const publicKey = KeylessPublicKey.create(args);\n    super({ publicKey, ...args });\n    this.publicKey = publicKey;\n  }\n\n  /**\n   * Serializes the transaction data into a format suitable for transmission or storage.\n   * This function ensures that both the transaction bytes and the proof are properly serialized.\n   *\n   * @param serializer - The serializer instance used to convert the transaction data into bytes.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  serialize(serializer: Serializer): void {\n    super.serialize(serializer);\n  }\n\n  /**\n   * Deserializes the provided deserializer to create a KeylessAccount instance.\n   * This function extracts necessary components such as the JWT, UID key, pepper, ephemeral key pair, and proof from the deserializer.\n   *\n   * @param deserializer - The deserializer instance used to retrieve the serialized data.\n   * @returns A KeylessAccount instance created from the deserialized data.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static deserialize(deserializer: Deserializer): KeylessAccount {\n    const { address, proof, ephemeralKeyPair, jwt, uidKey, pepper, verificationKeyHash } =\n      AbstractKeylessAccount.partialDeserialize(deserializer);\n    const { iss, aud, uidVal } = getIssAudAndUidVal({ jwt, uidKey });\n    return new KeylessAccount({\n      address,\n      proof,\n      ephemeralKeyPair,\n      iss,\n      uidKey,\n      uidVal,\n      aud,\n      pepper,\n      jwt,\n      verificationKeyHash,\n    });\n  }\n\n  /**\n   * Deserialize bytes using this account's information.\n   *\n   * @param bytes The bytes being interpreted.\n   * @returns\n   */\n  static fromBytes(bytes: HexInput): KeylessAccount {\n    return KeylessAccount.deserialize(new Deserializer(Hex.hexInputToUint8Array(bytes)));\n  }\n\n  /**\n   * Creates a KeylessAccount instance using the provided parameters.\n   * This function allows you to set up a KeylessAccount with specific attributes such as address, proof, and JWT.\n   * This is used instead of the KeylessAccount constructor.\n   *\n   * @param args - The parameters for creating a KeylessAccount.\n   * @param args.address - Optional account address associated with the KeylessAccount.\n   * @param args.proof - A Zero Knowledge Signature or a promise that resolves to one.\n   * @param args.jwt - A JSON Web Token used for authentication.\n   * @param args.ephemeralKeyPair - The ephemeral key pair used in the account creation.\n   * @param args.pepper - A hexadecimal input used for additional security.\n   * @param args.uidKey - Optional key for user identification, defaults to \"sub\".\n   * @param args.proofFetchCallback - Optional callback function for fetching proof.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static create(args: {\n    address?: AccountAddress;\n    proof: ZeroKnowledgeSig | Promise<ZeroKnowledgeSig>;\n    jwt: string;\n    ephemeralKeyPair: EphemeralKeyPair;\n    pepper: HexInput;\n    uidKey?: string;\n    proofFetchCallback?: ProofFetchCallback;\n    verificationKey?: Groth16VerificationKey;\n  }): KeylessAccount {\n    const { address, proof, jwt, ephemeralKeyPair, pepper, uidKey = \"sub\", proofFetchCallback, verificationKey } = args;\n\n    const { iss, aud, uidVal } = getIssAudAndUidVal({ jwt, uidKey });\n    return new KeylessAccount({\n      address,\n      proof,\n      ephemeralKeyPair,\n      iss,\n      uidKey,\n      uidVal,\n      aud,\n      pepper,\n      jwt,\n      proofFetchCallback,\n      verificationKeyHash: verificationKey ? verificationKey.hash() : undefined,\n    });\n  }\n}\n"],"mappings":"2KAwBO,IAAMA,EAAN,MAAMC,UAAuBC,CAAuB,CA6BzD,YAAYC,EAYT,CACD,IAAMC,EAAYC,EAAiB,OAAOF,CAAI,EAC9C,MAAM,CAAE,UAAAC,EAAW,GAAGD,CAAK,CAAC,EAC5B,KAAK,UAAYC,CACnB,CAUA,UAAUE,EAA8B,CACtC,MAAM,UAAUA,CAAU,CAC5B,CAWA,OAAO,YAAYC,EAA4C,CAC7D,GAAM,CAAE,QAAAC,EAAS,MAAAC,EAAO,iBAAAC,EAAkB,IAAAC,EAAK,OAAAC,EAAQ,OAAAC,EAAQ,oBAAAC,CAAoB,EACjFZ,EAAuB,mBAAmBK,CAAY,EAClD,CAAE,IAAAQ,EAAK,IAAAC,EAAK,OAAAC,CAAO,EAAIC,EAAmB,CAAE,IAAAP,EAAK,OAAAC,CAAO,CAAC,EAC/D,OAAO,IAAIX,EAAe,CACxB,QAAAO,EACA,MAAAC,EACA,iBAAAC,EACA,IAAAK,EACA,OAAAH,EACA,OAAAK,EACA,IAAAD,EACA,OAAAH,EACA,IAAAF,EACA,oBAAAG,CACF,CAAC,CACH,CAQA,OAAO,UAAUK,EAAiC,CAChD,OAAOlB,EAAe,YAAY,IAAImB,EAAaC,EAAI,qBAAqBF,CAAK,CAAC,CAAC,CACrF,CAkBA,OAAO,OAAOhB,EASK,CACjB,GAAM,CAAE,QAAAK,EAAS,MAAAC,EAAO,IAAAE,EAAK,iBAAAD,EAAkB,OAAAG,EAAQ,OAAAD,EAAS,MAAO,mBAAAU,EAAoB,gBAAAC,CAAgB,EAAIpB,EAEzG,CAAE,IAAAY,EAAK,IAAAC,EAAK,OAAAC,CAAO,EAAIC,EAAmB,CAAE,IAAAP,EAAK,OAAAC,CAAO,CAAC,EAC/D,OAAO,IAAIX,EAAe,CACxB,QAAAO,EACA,MAAAC,EACA,iBAAAC,EACA,IAAAK,EACA,OAAAH,EACA,OAAAK,EACA,IAAAD,EACA,OAAAH,EACA,IAAAF,EACA,mBAAAW,EACA,oBAAqBC,EAAkBA,EAAgB,KAAK,EAAI,MAClE,CAAC,CACH,CACF","names":["KeylessAccount","_KeylessAccount","AbstractKeylessAccount","args","publicKey","KeylessPublicKey","serializer","deserializer","address","proof","ephemeralKeyPair","jwt","uidKey","pepper","verificationKeyHash","iss","aud","uidVal","getIssAudAndUidVal","bytes","Deserializer","Hex","proofFetchCallback","verificationKey"]}